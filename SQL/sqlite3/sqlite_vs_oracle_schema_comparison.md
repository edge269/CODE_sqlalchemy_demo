# SQLite3 vs Oracle SQL Schema Comparison: Nuclear Fuel Assembly Example

| Feature                | SQLite3 Example                                   | Oracle Example                                         |
|------------------------|---------------------------------------------------|--------------------------------------------------------|
| **Auto-increment PK**  | `INTEGER PRIMARY KEY AUTOINCREMENT`               | `NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY`  |
| **String type**        | `TEXT` or `VARCHAR`                               | `VARCHAR2(n)`                                          |
| **Integer type**       | `INTEGER`                                         | `NUMBER`                                               |
| **Float type**         | `REAL`                                            | `FLOAT`                                                |
| **Foreign key syntax** | `FOREIGN KEY (col) REFERENCES table(id)`          | `CONSTRAINT fk_name FOREIGN KEY (col) REFERENCES ...`  |
| **Table/column names** | Case-insensitive, flexible                        | Case-insensitive, but best practice: UPPERCASE         |
| **Schema changes**     | Permissive, simple                                | Strict, explicit, often requires more steps            |

---

## Example: FUEL_ASSEMBLY Table

### SQLite3
```sql
CREATE TABLE FUEL_ASSEMBLY (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    FA_name TEXT NOT NULL,
    FA_mass REAL NOT NULL,
    FA_length_ft INTEGER NOT NULL,
    FA_manufacturing_year INTEGER NOT NULL,
    FA_BUp REAL NOT NULL,
    reactor_core_id INTEGER NOT NULL,
    reactor_site_id INTEGER NOT NULL,
    reactor_epoch_id INTEGER NOT NULL,
    introduction_year INTEGER NOT NULL,
    FOREIGN KEY (reactor_core_id) REFERENCES REACTOR_CORE(id),
    FOREIGN KEY (reactor_site_id) REFERENCES REACTOR_SITES(id),
    FOREIGN KEY (reactor_epoch_id) REFERENCES REACTOR_EPOCHS(id)
);
```

### Oracle
```sql
CREATE TABLE FUEL_ASSEMBLY (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    FA_name VARCHAR2(8) NOT NULL,
    FA_mass FLOAT NOT NULL,
    FA_length_ft NUMBER(2) NOT NULL,
    FA_manufacturing_year NUMBER(4) NOT NULL,
    FA_BUp FLOAT NOT NULL,
    reactor_core_id NUMBER NOT NULL,
    reactor_site_id NUMBER NOT NULL,
    reactor_epoch_id NUMBER NOT NULL,
    introduction_year NUMBER(4) NOT NULL,
    CONSTRAINT fk_core FOREIGN KEY (reactor_core_id) REFERENCES REACTOR_CORE(id),
    CONSTRAINT fk_site FOREIGN KEY (reactor_site_id) REFERENCES REACTOR_SITES(id),
    CONSTRAINT fk_epoch FOREIGN KEY (reactor_epoch_id) REFERENCES REACTOR_EPOCHS(id)
);
```

---

**Key Takeaways:**
- SQLite3 is simpler and more permissive, ideal for prototyping and local development.
- Oracle is stricter, with more explicit data types and constraint naming, suitable for enterprise production environments.
